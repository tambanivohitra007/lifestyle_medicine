<?php

namespace App\Services;

use Google\Cloud\AIPlatform\V1\Client\PredictionServiceClient;
use Google\Cloud\AIPlatform\V1\PredictRequest;
use Google\Protobuf\Value;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;

class ImagenService
{
    protected ?string $projectId;
    protected ?string $location;
    protected ?string $credentials;
    protected string $model;

    public function __construct()
    {
        $this->projectId = config('services.vertex_ai.project_id');
        $this->location = config('services.vertex_ai.location', 'us-central1');
        $this->credentials = config('services.vertex_ai.credentials');
        $this->model = config('services.vertex_ai.imagen_model', 'imagen-4.0-fast-generate-001');
    }

    /**
     * Check if Vertex AI Imagen is configured.
     */
    public function isConfigured(): bool
    {
        return !empty($this->projectId)
            && !empty($this->credentials)
            && file_exists($this->credentials);
    }

    /**
     * Generate an image using Vertex AI Imagen.
     *
     * @param string $prompt The text prompt for image generation
     * @param array $options Optional parameters (aspectRatio, sampleCount, etc.)
     * @return array{success: bool, image_data?: string, error?: string}
     */
    public function generateImage(string $prompt, array $options = []): array
    {
        if (!$this->isConfigured()) {
            return [
                'success' => false,
                'error' => 'Vertex AI Imagen is not configured. Please set VERTEX_AI_PROJECT_ID and GOOGLE_APPLICATION_CREDENTIALS.',
            ];
        }

        try {
            // Set credentials environment variable for the Google Cloud client
            putenv("GOOGLE_APPLICATION_CREDENTIALS={$this->credentials}");

            $endpoint = sprintf(
                'projects/%s/locations/%s/publishers/google/models/%s',
                $this->projectId,
                $this->location,
                $this->model
            );

            $client = new PredictionServiceClient([
                'apiEndpoint' => "{$this->location}-aiplatform.googleapis.com",
            ]);

            // Build the instance (prompt)
            $instanceValue = new Value();
            $instanceValue->setStructValue(
                new \Google\Protobuf\Struct([
                    'fields' => [
                        'prompt' => (new Value())->setStringValue($prompt),
                    ],
                ])
            );

            // Build parameters
            $parametersStruct = new \Google\Protobuf\Struct();
            $fields = [
                'sampleCount' => (new Value())->setNumberValue($options['sampleCount'] ?? 1),
            ];

            // Add aspect ratio if specified (default 1:1 for infographics)
            if (isset($options['aspectRatio'])) {
                $fields['aspectRatio'] = (new Value())->setStringValue($options['aspectRatio']);
            } else {
                // Portrait orientation is good for infographics
                $fields['aspectRatio'] = (new Value())->setStringValue('3:4');
            }

            $parametersStruct->setFields($fields);
            $parametersValue = new Value();
            $parametersValue->setStructValue($parametersStruct);

            $request = new PredictRequest([
                'endpoint' => $endpoint,
                'instances' => [$instanceValue],
                'parameters' => $parametersValue,
            ]);

            $response = $client->predict($request);
            $predictions = $response->getPredictions();

            if (count($predictions) === 0) {
                return [
                    'success' => false,
                    'error' => 'No image was generated by the model.',
                ];
            }

            // Extract base64 image data from the first prediction
            $prediction = $predictions[0];
            $structValue = $prediction->getStructValue();
            $imageData = null;

            if ($structValue) {
                $fields = $structValue->getFields();
                if (isset($fields['bytesBase64Encoded'])) {
                    $imageData = $fields['bytesBase64Encoded']->getStringValue();
                }
            }

            if (!$imageData) {
                return [
                    'success' => false,
                    'error' => 'Failed to extract image data from response.',
                ];
            }

            $client->close();

            return [
                'success' => true,
                'image_data' => $imageData,
            ];

        } catch (\Exception $e) {
            Log::error('Imagen generation error: ' . $e->getMessage(), [
                'prompt' => Str::limit($prompt, 100),
                'trace' => $e->getTraceAsString(),
            ]);

            return [
                'success' => false,
                'error' => 'Image generation failed: ' . $e->getMessage(),
            ];
        }
    }

    /**
     * Save base64 image data to storage and return the path.
     *
     * @param string $base64Data The base64 encoded image data
     * @param string $filename The desired filename (without extension)
     * @param string $directory The storage directory
     * @return array{success: bool, path?: string, filename?: string, size?: int, error?: string}
     */
    public function saveImage(string $base64Data, string $filename, string $directory = 'infographics'): array
    {
        try {
            $imageData = base64_decode($base64Data);

            if ($imageData === false) {
                return [
                    'success' => false,
                    'error' => 'Failed to decode base64 image data.',
                ];
            }

            // Detect image type from data
            $finfo = new \finfo(FILEINFO_MIME_TYPE);
            $mimeType = $finfo->buffer($imageData);
            $extension = $this->getExtensionFromMime($mimeType);

            $fullFilename = $filename . '.' . $extension;
            $path = $directory . '/' . $fullFilename;

            Storage::disk('public')->put($path, $imageData);

            return [
                'success' => true,
                'path' => $path,
                'filename' => $fullFilename,
                'size' => strlen($imageData),
                'mime_type' => $mimeType,
            ];

        } catch (\Exception $e) {
            Log::error('Failed to save image: ' . $e->getMessage());

            return [
                'success' => false,
                'error' => 'Failed to save image: ' . $e->getMessage(),
            ];
        }
    }

    /**
     * Get file extension from MIME type.
     */
    protected function getExtensionFromMime(string $mimeType): string
    {
        $map = [
            'image/png' => 'png',
            'image/jpeg' => 'jpg',
            'image/jpg' => 'jpg',
            'image/webp' => 'webp',
            'image/gif' => 'gif',
        ];

        return $map[$mimeType] ?? 'png';
    }

    /**
     * Get the configured Imagen model.
     */
    public function getModel(): string
    {
        return $this->model;
    }

    /**
     * Get configuration status details.
     */
    public function getConfigurationStatus(): array
    {
        return [
            'configured' => $this->isConfigured(),
            'project_id' => $this->projectId ? '***' . substr($this->projectId, -4) : null,
            'location' => $this->location,
            'model' => $this->model,
            'credentials_exist' => $this->credentials && file_exists($this->credentials),
        ];
    }
}
