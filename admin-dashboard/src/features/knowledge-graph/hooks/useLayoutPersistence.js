import { useCallback, useEffect, useRef } from 'react';

const STORAGE_KEY_PREFIX = 'kg-layout-';
const DEBOUNCE_MS = 1000;

/**
 * Hook for persisting and restoring graph layout positions to localStorage.
 * Saves node positions when they change and restores them on mount.
 */
export function useLayoutPersistence(graphId, nodes, setNodes, enabled = true) {
  const timeoutRef = useRef(null);
  const isRestoredRef = useRef(false);

  const storageKey = `${STORAGE_KEY_PREFIX}${graphId}`;

  // Save positions to localStorage (debounced)
  const savePositions = useCallback(() => {
    if (!enabled || !graphId) return;

    // Only save content nodes (not groups), as groups are generated by layout
    const positionsToSave = {};
    nodes.forEach((node) => {
      if (node.type !== 'group' && node.position) {
        positionsToSave[node.id] = {
          x: node.position.x,
          y: node.position.y,
        };
      }
    });

    try {
      localStorage.setItem(storageKey, JSON.stringify({
        positions: positionsToSave,
        timestamp: Date.now(),
      }));
    } catch (error) {
      console.warn('Failed to save layout positions:', error);
    }
  }, [enabled, graphId, nodes, storageKey]);

  // Debounced save on node changes
  useEffect(() => {
    if (!enabled || !isRestoredRef.current) return;

    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    timeoutRef.current = setTimeout(() => {
      savePositions();
    }, DEBOUNCE_MS);

    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [nodes, savePositions, enabled]);

  // Restore positions from localStorage
  const restorePositions = useCallback((nodesToRestore) => {
    if (!enabled || !graphId) return nodesToRestore;

    try {
      const savedData = localStorage.getItem(storageKey);
      if (!savedData) return nodesToRestore;

      const { positions, timestamp } = JSON.parse(savedData);

      // Check if saved data is not too old (7 days)
      const maxAge = 7 * 24 * 60 * 60 * 1000;
      if (Date.now() - timestamp > maxAge) {
        localStorage.removeItem(storageKey);
        return nodesToRestore;
      }

      // Apply saved positions to nodes
      const restoredNodes = nodesToRestore.map((node) => {
        if (node.type !== 'group' && positions[node.id]) {
          return {
            ...node,
            position: positions[node.id],
          };
        }
        return node;
      });

      isRestoredRef.current = true;
      return restoredNodes;
    } catch (error) {
      console.warn('Failed to restore layout positions:', error);
      return nodesToRestore;
    }
  }, [enabled, graphId, storageKey]);

  // Clear saved positions
  const clearSavedPositions = useCallback(() => {
    try {
      localStorage.removeItem(storageKey);
    } catch (error) {
      console.warn('Failed to clear layout positions:', error);
    }
  }, [storageKey]);

  // Mark as restored when nodes are set initially
  useEffect(() => {
    if (nodes.length > 0 && !isRestoredRef.current) {
      isRestoredRef.current = true;
    }
  }, [nodes.length]);

  return {
    restorePositions,
    savePositions,
    clearSavedPositions,
  };
}

export default useLayoutPersistence;
